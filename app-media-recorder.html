<!--
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../polymer/polymer.html">

<!--
`app-media-recorder` is an element that, when configured with a media stream,
generates recordings based on that stream and produces them as blobs for further
consumption and processing.

NOTE: As of today (January 6th, 2017), Media Recorder API is only supported in
Chrome, Firefox and Opera. This element will politely neglect to register itself
in browsers that do not support the Media Recorder API.

@group App Elements
@demo demo/index.html
-->

<dom-module id="app-media-recorder">
  <script>
    (function() {
      if (window.MediaRecorder == null) {
        console.warn('Media Recorder API is not supported in this browser!');
        return;
      }

      Polymer({
        is: 'app-media-recorder',

        properties: {
          /**
           * The input media stream to base the recordings off of.
           */
          stream: {
            type: MediaStream
          },

          /**
           * A reference to the media recorder that is used to generate
           * recordings of the stream.
           */
          recorder: {
            type: MediaRecorder,
            notify: true,
            computed: '_computeRecorder(stream, mimeType)'
          },

          /**
           * The timeslice to use when recording the stream with the media
           * recorder.
           */
          timeslice: {
            type: Number,
            value: 10
          },

          /**
           * The duration of the recording, in milliseconds. If set to a value
           * greater than 0, the recording will automatically end after the
           * configured amount of time (unless there is some manual
           * intervention). If set to 0 (the default), recording will continue
           * until manually stopped (or your device melts).
           */
          duration: {
            type: Number,
            value: 0
          },

          /**
           * The computed mime type for the output recording.
           */
          mimeType: {
            type: String,
            computed: '_computeMimeType(stream, mpeg, codecs)',
            observer: '_mimeTypeChanged'
          },

          /**
           * If true, the computed mime type will be video/mpeg.
           */
          mpeg: {
            type: Boolean,
            value: false
          },

          /**
           * If a value is given, the computed mime time will include a suffix
           * specifying the value as a specific codec e.g., for vp8, the mime
           * type will be video/webm\;codecs=vp8.
           */
          codecs: {
            type: String,
            value: null
          },

          /**
           * The time elapsed since the recorder began recording, in
           * milliseconds.
           */
          elapsed: {
            type: Number,
            readOnly: true,
            notify: true,
            value: 0
          },

          /**
           * A blob for the most recently completed recording.
           */
          data: {
            type: Blob,
            readOnly: true,
            notify: true
          }
        },

        /**
         * Start recording from the source media stream.
         */
        start: function() {
          var data = [];
          var start = performance.now();
          var finished = false;

          var onDataAvailable = function(event) {
            var elapsed = performance.now() - start;

            if (event.data && event.data.size > 0) {
              data.push(event.data);
            }

            if (this.duration > 0 && this.duration < elapsed && !finished) {
              elapsed = this.duration;
              finished = true;
              this.stop();
            }

            this._setElapsed(elapsed);
          }.bind(this);

          var onStop = function() {
            this.recorder.removeEventListener('dataavailable', onDataAvailable);
            this.recorder.removeEventListener('stop', onStop);

            this._setData(new Blob(data, {
              type: this.mimeType
            }));
          }.bind(this);

          this.stop();

          this.recorder.addEventListener('dataavailable', onDataAvailable);
          this.recorder.addEventListener('stop', onStop);

          this.recorder.start(this.timeslice);
        },

        /**
         * Stop recording from the source media stream. The result of the
         * recording will be made available as a new value for the data
         * property.
         */
        stop: function() {
          this._setElapsed(0);
          if (this.recorder.state !== 'inactive') {
            this.recorder.stop();
          }
        },

        _computeRecorder: function(stream, mimeType) {
          if (mimeType == null) {
            return;
          }

          return new MediaRecorder(stream, {
            mimeType: mimeType
          });
        },

        _computeMimeType: function(stream, mpeg, codecs) {
          if (stream == null) {
            return;
          }

          var candidate;

          if (mpeg) {
            candidate = 'video/mpeg';
          } else if (stream.getVideoTracks().length > 0) {
            candidate = 'video/webm';
          } else {
            candidate = 'audio/webm';
          }

          if (codecs) {
            // NOTE(cdata): This specifies a codec if one is preferred by the user
            // configuration of an element.
            // A reference for the mimetype format can be found here:
            // https://tools.ietf.org/html/rfc2046
            // Examples of specifying codecs in mimetypes can be found here:
            // https://www.w3.org/TR/mediastream-recording/#check-for-mediarecorder-and-mimetype.x
            candidate += '\;codecs=' + codecs;
          }

          return candidate || '';
        },

        _mimeTypeChanged: function(mimeType) {
          if (!mimeType) {
            return;
          }

          if (!MediaRecorder.isTypeSupported(mimeType)) {
            console.warn('Browser does not support mime-type', mimeType);
          }
        }
      });
    })();
  </script>
</dom-module>

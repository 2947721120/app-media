<!--
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">

<!--
`app-media-video` is an element that converts a video source into a nicely
scaled video that is displayed to the viewer of the page.

@group App Elements
@demo demo/index.html
-->

<dom-module id="app-media-video">
  <template>
    <style>
      :host {
        display: flex;
        align-items: center;
        justify-content: center;
        flex-wrap: nowrap;
        width: 100%;
        height: 100%;
        background: var(--app-media-video-background, #000);
        overflow: hidden;
      }

      video {
        flex: 0 0 100%;
        transform-origin: center center;
      }
    </style>
    <video
        id="videoElement"
        on-loadedmetadata="_updateMetrics"
        muted="[[muted]]"
        autoplay="[[autoplay]]"
        loop="[[loop]]">
    </video>
  </template>
  <script>
    (function() {
      Polymer({
        is: 'app-media-video',

        behaviors: [
          Polymer.IronResizableBehavior
        ],

        properties: {
          /**
           * The input source for the element. This can be a Media Stream, a
           * Blob or a string URL.
           * @type {MediaStream|Blob|string}
           */
          source: {
            type: Object,
            notify: true,
            observer: '_sourceChanged'
          },

          /**
           * If true, the video will be scaled so that the source video is
           * flush with the edge of the element, but fully contained by it. If
           * false (the default), the video will be scaled to the smallest size
           * that is at full-bleed with respect to the element's bounding box.
           * Both settings preserve the aspect ratio of the source video.
           */
          contain: {
            type: Boolean,
            value: false
          },

          /**
           * If true, the video will be inverted along the x-axis so that it is
           * effectively mirrored.
           */
          mirror: {
            type: Boolean,
            value: false
          },

          /**
           * If true, the video is muted.
           */
          muted: {
            type: Boolean,
            value: false
          },

          /**
           * If true, the video will automatically play when it has a source.
           */
          autoplay: {
            type: Boolean,
            value: false
          },

          /**
           * If true, the video will loop when it reaches the end of the source.
           */
          loop: {
            type: Boolean,
            value: false
          },

          /**
           * A bindable reference to the video element that actually plays the
           * source. This is sometimes useful in conjunction with
           * `app-media-audio`, which can accept an HTMLVideoElement as its
           * source.
           */
          videoElement: {
            type: HTMLVideoElement,
            notify: true,
            readOnly: true
          }
        },

        listeners: {
          'videoElement.loadedmetadata': '_updateMetrics',
          'iron-resize': '_updateMetrics'
        },

        observers: [
          '_updateMetrics(contain, mirror)'
        ],

        attached: function() {
          this._setVideoElement(this.$.videoElement);
          this._updateMetrics();
        },

        /**
         * Play the video.
         */
        play: function() {
          this.$.videoElement.play();
        },

        /**
         * Pause the video.
         */
        pause: function() {
          this.$.videoElement.pause();
        },

        _sourceChanged: function() {
          var oldSrc = this.$.videoElement.src;

          if (typeof this.source === 'string') {
            this.$.videoElement.src = this.source;
          } else {
            try {
              // NOTE(cdata): Chrome as of 55 does not support anything other than
              // MediaStream as the value of srcObject (even though the value is
              // allowed to be Blob, per the spec). We try the standardized way,
              // and then fall back to URL.createObjectURL if necessary.
              this.$.videoElement.srcObject = this.source;
            } catch (e) {
              if (this.source instanceof Blob) {
                this.$.videoElement.src = URL.createObjectURL(this.source, {
                  type: this.source.type
                });
              } else {
                this._error(this._logf(e));
              }
            }
          }

          if (typeof oldSrc === 'string') {
            try {
              URL.revokeObjectURL(oldSrc);
            } catch (e) {}
          }
          // NOTE(cdata): No need to manually update metrics here, since the
          // new source will cause the video element to fire a loadmetadata
          // event when it is ready.
        },

        _updateMetrics: function() {
          this.debounce('_updateMetrics', function() {
            var videoWidth = this.$.videoElement.videoWidth;
            var videoHeight = this.$.videoElement.videoHeight;

            if (!videoWidth || !videoHeight) {
              this.$.videoElement.style.visibility = 'hidden';
              return;
            } else {
              this.$.videoElement.style.visibility = '';
            }

            var selfRect = this.getBoundingClientRect();
            var selfRatio = selfRect.width / selfRect.height;
            var videoRatio = videoWidth / videoHeight;
            var videoScale;
            var scaleByHeight = this.contain
                ? videoRatio < selfRatio
                : videoRatio > selfRatio;

            if (scaleByHeight) {
              videoScale = selfRect.height / videoHeight;
            } else {
              videoScale = selfRect.width / videoWidth;
            }

            this.$.videoElement.style.transform =
                'scale(' + (this.mirror ? -videoScale : videoScale) + ',' + videoScale + ')';
          });
        }
      });
    })();
  </script>
</dom-module>
